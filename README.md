# ImageBook Microservices

This repository contains links and documentation for the ImageBook project's microservices.

## Microservices

- [ImageBook Client](https://github.com/EgSundqvist/imagebook-client): Frontend application built with React and TypeScript.
- [ImageBook User API](https://github.com/EgSundqvist/imagebook-userapi): API for user management, built with Python.
- [ImageBook Image API](https://github.com/EgSundqvist/imagebook-imageapi): API for image management, built with Go.

## Documentation

### Example of application flow

![Example of application flow](https://github.com/EgSundqvist/imagebook/blob/main/ImagebookMicroservicesFlow.png)

### CI/CD and cluster flow

![CI/CD and cluster flow](https://github.com/EgSundqvist/imagebook/blob/main/ImagebookClusterFlow.png)

## Purpose

The purpose of this project has been to build an application according to Cloud Native principles. This concept includes:
- Logic and functionality divided into small microservices instead of larger APIs and services.
- Container technology such as Docker to package and isolate applications and services, optimizing hardware performance.
- Orchestration with tools such as Kubernetes for distributing and scaling container-based applications.
- CI/CD for continuous integration and delivery, automating workflows and processes in development such as CodeBuild.

Additionally, my aim was to develop my knowledge in two previously unfamiliar languages commonly used for building microservices: Go and Python.

## Description and Use

Imagebook is a web application intended as a private photo album. Currently, users can register, log in, manage accounts and profiles, upload and delete images, and view their uploaded images in an infinite scroll. There are plans to expand the application with more social and interactive functionalities, such as interacting with other users and viewing their resources.

## Client - React

The client, built with React, provides a clean and logical interface for managing images and user profile information. React Router is used for routing, providing a clear navigation experience with SPA (Single Page Application) behavior. It also distinguishes between public and protected pages based on user authentication.

JSON Web Tokens generated by the User API upon login are used for authenticated requests. Tokens are stored in LocalStorage and managed with Redux to maintain global state across the application and handle authentication status. The application uses a timer to track token validity and automatically logs the user out when the token expires.

TanStack Query is used to display the user's images in an infinite scroll with caching functionalities. MUI provides functional components that are further customized to fit the application. A clear and consistent project structure is maintained through naming conventions, separating code into components, hooks, and pages to keep file sizes manageable and facilitate code reuse.

## ImageAPI - Go

This API is written in Go and handles images via requests from the client and User API. It uses libraries such as GORM, Gin, and the AWS SDK, and follows a design pattern with repositories for database methods. In the development environment, SQLite is used as a database, and in the production environment, MySQL is used. To manage and store parameters that differ between the environments and to protect secret keys, environment variables and the AWS Parameter Store are used.

The API has endpoints for uploading, deleting, and retrieving images in pages. It also has an endpoint for creating a new folder in the S3 bucket based on the user ID assigned to new users when they register. The images are saved in an S3 bucket in AWS, and their metadata is saved in the database.

A central and important functionality in this API is the integration with AWS S3. For this, the AWS SDK is used to establish a session. Handlers that manage traffic to S3 generally have two endpoints. For example, `/upload-url` receives the file name and description, then establishes a session with AWS and generates a "presigned" URL that is sent back to the client so the client can use it to upload the image directly to S3. If that request is successful, the client proceeds to `/confirm-upload`, where the client sends the regular S3 URL (not presigned) and description in the request. This and other metadata are then saved in the database. The keys to unlock the user who has rights in AWS are stored in the `.env` file locally and in Kubernetes secrets in the production environment.

## UserAPI - Python

This API is built in Python and handles users, profiles, login, and registration. It uses libraries such as Flask with "sublibraries," Werkzeug Security (password hashing), and SQLAlchemy. This API also uses SQLite in the development environment and MySQL in the production environment in Kubernetes, and has environment variables that control which passwords and URLs to use depending on the environment. It also follows a design pattern where it uses repositories for database methods.

A central and important function in this API is the login endpoint that generates a JWT containing the user's ID and token validity period in the payload. This way, the remaining endpoints can be more general and secure by not addressing a specific ID in the route. Instead, for example, `/current-user` is called, where the user ID is retrieved directly from the token. This ensures that the token only provides access to the user's own resources.

The token is signed with a secret key that is shared with the ImageAPI, which uses this to validate incoming requests via the client. Communication also takes place directly between the UserAPI and ImageAPI. When a user registers, the UserAPI sends a request to the ImageAPI, which in turn connects to AWS S3 and creates a new folder for images based on the user's assigned ID. In this request, the UserAPI generates a token that is signed and validated by the ImageAPI. For security reasons and to prevent misuse of the ImageAPI endpoint, a separate key and token are used that are not exposed to the user.

## CI/CD

All services are published to GitHub repositories with AWS CodeBuild listening for changes, building images, and pushing them to a private Git server in the cluster. Kubernetes uses these images to deploy the application through pods (containers).

## Kubernetes

The Kubernetes cluster uses a node balancer to distribute incoming traffic, optimize resource usage, and ensure data persistence with PVC. Cert-manager handles HTTPS certificates, and Ingress manages external access. Keys and parameters are stored in Kubernetes secrets, base64-encoded. Linode's interface and Keel are used for managing pods and applications, with Keel controlling polling behaviors against the image registry.

## Future Functionality

Currently an MVP (Minimum Viable Product), planned future functionalities include:
- Tests
- Database backup
- Interactive features for users to search and interact with others and view their resources
- Rate-limiting
- Email server for authentication and password recovery
- Input validation
- Image optimization

## Lessons Learned

This project has been incredibly educational. Key takeaways include:
- Strategic logging is crucial, especially in Kubernetes environments where debugging access is limited.
- Breaking code into smaller components improves readability, understanding, and maintenance.
- Using environment variables for differing local and Kubernetes parameters allows for smooth transitions without constant changes.
